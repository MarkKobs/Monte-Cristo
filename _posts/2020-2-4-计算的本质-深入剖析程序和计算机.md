---
title: 计算的本质-深入剖析程序与计算机
date: 2020-02-04 11:41:00 
tags: ruby
category: 形式化
---

计算的本质-深入剖析程序与计算机是一本可以反复读的好书，一些学习的记录作于此，以便温故知新。

## ruby上手

先以一个例子熟悉ruby的对象和方法

**1、对象，方法，消息**

```ruby
o=Object.new
def o.add(x,y)
  x+y
end
o.add(2,3)
```

> 创建对象

> 定义方法：包括接收对象o，名字add和参数x、y

> 对象.消息名(方法名)（参数1，参数2）



**2、对象追踪**

```ruby
def o.add_twice(x,y)
  add(x,y)+add(x,y)
end
o.add(2,3)
```

Ruby默认追踪当前对象(self)，在方法定义内部，可不必显示提及接收对象。



**3、默认main的特殊顶层对象**

```ruby
def multiply(a,b)
  a*b
end
multiply(2,3)
```

在没有指明接收对象时，默认为main的特殊顶层对象。



**4、类定义与类继承**

```ruby
class Calculator
  def add(x,y)
    x+Y
  end
end
```

```ruby
class MultiplyingCalculator < Calculator
  def multiply(x,y)
    x*y
  end
end
```



**5、模块**

```ruby
module Addition
  把方法定义在这
end

class NewClass
  include Addtion
end
```



**6、字符串插值**

对于双引号中的字符串，ruby会自动将表达式的结果替换#{表达式}

```ruby
>>"hello #{'dlrow'.reverse}"
=>"hello world"
```

```ruby
>>"#{2+3}"
=>"5"
```

假如被插入的表达式返回的不是一个字符串类型的对象，那么这个对象就会自动调用一个to_s消息以返回能顶替其位置的字符串。

```ruby
>>o=Object.new
>>def o.to_s
  'a new object'
end
>> "here is #{0}"
```



**7、inspect**

通常这个函数和to_s一样，直接调用to_s，但是它的功能不同，通常用于在IRB中检查一个对象的状态，还可以包含其他信息。

```ruby
>>o=Object.new
>>def o.inspect
  '[my object]'
end
>>o
```



**8、可变参数方法**

```ruby
def join_with_commas(*words)
  words.join(',')
end

>>join_with_commas('one','two','three')
```

一个方法只能有一个可变参数，而常规参数可以放到可变参数的前后：

```ruby
>>def join_with_commas(before,*words,after)
  before+words.join(',')+after
end
>>join_with_commas("Testing:",1,2,3,'.')
```



**9、代码块**

`代码块`是由大括号围住的一段代码，可以用do/end或者大括号围住。方法可以带一个隐式代码块参数，并使用yield关键字表示对代码块中那段代码的调用。

```ruby
>> def do_three
  yield
  yield
  yield
end
=> nil
>>do_three{puts "hello"}
hello
hello
hello
=>nil
>>do_three do puts "hello" end
hello
hello
hello
=>nil
```

代码块可以带参数

```ruby
>>def do_three
  yield("first")
  yield("second")
  yield("third")
end
=>nil
>>do_three{|n| puts "#{n}:hello"}
first:hello
second:hello
third:hello
=>nil
```

yield返回代码块执行的结果：

```ruby
>>def num_names
  [yield('one'),yield('two'),yield('three')].join(',')
end
=>nil
>>num_names{|name| name.upcase.reverse}
=>"ENO,OWT,EERHT"
```



**10、枚举类型**

```ruby
>>(1..10).count{|num| num.even?}
=> 5
>>(1..10).select{|num| num.even?}
=> [2, 4, 6, 8, 10]
>>(1..10).any?{|num| num<8}
=> true
>>(1..10).all?{|num| num<8}
=> false
>>(1..5).each do |number|
  if number.even?
    puts "#{number} is even"
  else
    puts "#{number} is odd"
  end
 end
1 is odd
2 is even
3 is odd
4 is even
5 is odd
=> 1..5
>>(1..10).map{|number| number*3}
=> [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]   
```



**11、结构体**

这一块是非常重要的一块内容。

```ruby
class Point < Struct.new(:x,:y)
  def +(other_point)
    Point.new(x+other_point.x,y+other_point.y)
  end
  def inspect
    "<Point (#{x},#{y})>"
  end
end
```

```ruby
>>a=Point.new(2,3)
=><Point (2,3)>
```



**12、给内置对象拓展方法（Monkey Patching）**

**！！！我们随时都可以给类或模块增加方法。这是一个强大的特性，通常叫做Monkey Patching，可以让我们扩展已有类的行为，后面将会经常用到：**

```ruby
class Point
  def -(other_point)
    Point.new(x-other_point.x,y-other_point.y)
  end
end
```

随时可以给Point类增加方法。



**13、常量**

有两种表示常量的方法：

```ruby
NUMBER=[1,2,3]
NUMBER.last
```

通常常量一旦被创建，就不能被重新赋值。（Ruby并不会阻止一个常量被重新赋值，但它会产生警告）

```ruby
warning: already initialized constant NUMBER
warning: previous definition of NUMBER was here
```

另外一种可以在类或模块中定义新的常量：

```ruby
class Greetings
  ENGLISH='hello'
  FRENCH='bonjour'
  GERMAN='guten Tag'
end
=>"guten Tag"
Greetings::FRENCH
=>"bonjour"
```



**14、删除常量**

如果我们想要重新定义某个类或者模块，而不是要拓展它们，实用的做法是让ruby删除这个常量。一个顶层常量可以通过给Object发送:remove_const消息来删除，同时还要把**常量名（symbol）**作为符号对象传进去。

```ruby
>>NUM = [1,2,3]
=>[1,2,3]
>>Object.send(:remove_const,:NUM)
=>[1,2,3]
>>NUM.last
NameError: uninitialized constant NUM
```



